const t=({initialState:t,context:e,onStateChange:a})=>{let r={value:t,context:e};return{getState:()=>r,setState:(t,e)=>{r={value:null!=t?t:r.value,context:null!=e?e:r.context},a(r)}}};var e,a,r,i;!function(t){t.idle="IDLE",t.active="ACTIVE"}(e||(e={})),function(t){t.initializing="INITIALIZING",t.selectTask="SELECT_TASK",t.task="TASK",t.taskCompletePrompt="TASK_COMPLETE_PROMPT",t.taskVoidPrompt="TASK_VOID_PROMPT",t.taskTimerEndPrompt="TASK_TIMER_END_PROMPT",t.shortBreak="SHORT_BREAK",t.longBreak="LONG_BREAK"}(a||(a={})),function(t){t.idle="IDLE",t.ready="READY",t.active="ACTIVE",t.paused="PAUSED"}(r||(r={})),function(t){t.task="TASK",t.shortBreak="SHORT_BREAK",t.longBreak="LONG_BREAK"}(i||(i={}));const s=({onStateChange:e,onTimerEnd:a,onTimerTick:i,ticker:s})=>{const{getState:n,setState:o}=t({initialState:r.idle,context:{timer:null},onStateChange:e}),m=new Map,c=()=>{const{timer:t}=n().context;if(t){const e=Object.assign(Object.assign({},t),{time:t.time-1});if(o(null,{timer:e}),0===e.time){s.stop(),a(e);const{timer:t}=n().context;t&&0===t.time&&o(r.idle,{timer:null})}}};return{clearMarkers:()=>{m.clear()},createTimer:({isInjected:t=!1,time:e,type:a})=>{o(r.ready,{timer:{isInjected:t,time:e,totalTime:e,type:a}})},destroyTimer:()=>{o(r.idle,{timer:null}),s.stop()},getMarker:t=>{var e;return null!==(e=m.get(t))&&void 0!==e?e:null},getState:n,pauseTimer:()=>{o(r.paused),s.stop()},setMarker:t=>{const{timer:e}=n().context;e&&m.set(t,{timer:e,timestamp:Date.now()})},startTimer:()=>{o(r.active),s.start((()=>{c(),i()}))}}},n=({createTicker:n,settings:o})=>{let m=o;const{batchedEmit:c,emit:l,on:k,off:T}=(()=>{const t={},e=new Map,a=(e,a)=>{var r;null===(r=t[e])||void 0===r||r.forEach((t=>t(a)))};return{batchedEmit:(t,r)=>{e.size>0?e.set(t,r):(e.set(t,r),setTimeout((()=>{for(const[t,r]of e)a(t,r);e.clear()}),0))},emit:a,off:(e,a)=>{const r=t[e];r&&(t[e]=r.filter((t=>t!==a)))},on:(e,a)=>{var r;const i=null!==(r=t[e])&&void 0!==r?r:[];i.push(a),t[e]=i}}})(),u=()=>{c("update",I())},d=(({onStateChange:e})=>{const{getState:r,setState:i}=t({initialState:a.initializing,context:{currentTaskId:null},onStateChange:e});return{completeTask:()=>{i(a.taskCompletePrompt)},getState:r,selectTask:t=>{i(a.task,{currentTaskId:t})},setAppState:t=>{i(t)},switchTask:()=>{i(a.selectTask,{currentTaskId:null})},unsetCurrentTask:()=>{i(null,{currentTaskId:null})},voidTask:()=>{i(a.taskVoidPrompt)}}})({onStateChange:u}),p=s({onStateChange:u,onTimerEnd:t=>{l("timerEnd",g()),t.isInjected||y(),d.getState().value===a.task?(p.setMarker("taskEnd"),d.setAppState(a.taskTimerEndPrompt),l("taskEnd",g())):d.getState().value!==a.taskCompletePrompt&&E(),S.startOvertimeCountdown({delay:m.overtimeDelay,taskId:d.getState().context.currentTaskId,type:t.type})},onTimerTick:()=>{l("timerTick",g())},ticker:n()}),S=(({onOvertimeStart:a,onOvertimeTick:r,onStateChange:i,ticker:s})=>{const{getState:n,setState:o}=t({initialState:e.idle,context:{overtime:null},onStateChange:i});let m=null;const c=()=>{const{overtime:t}=n().context;t&&(o(null,{overtime:Object.assign(Object.assign({},t),{time:t.time+1})}),r())};return{endOvertime:()=>{n().value===e.active?(o(e.idle,{overtime:null}),s.stop()):m&&(m(),m=null)},startOvertimeCountdown:({delay:t,taskId:r,type:i})=>{m=s.wait((()=>{const n={taskId:r,time:t,type:i};o(e.active,{overtime:n}),s.start(c),a(n)}),t)},getState:n}})({onOvertimeStart:t=>{l("overtimeStart",g({overtime:Object.assign(Object.assign({},t),{time:0}),timestamp:Date.now()-1e3*t.time}))},onOvertimeTick:()=>{l("overtimeTick",g())},onStateChange:u,ticker:n()});let v=0;const g=(t={})=>{const e=p.getState().context.timer;return Object.assign({taskId:d.getState().context.currentTaskId,timer:e?{time:e.time,totalTime:e.totalTime,type:e.type}:null,overtime:S.getState().context.overtime,timestamp:Date.now()},t)},y=()=>{v+=1,v>=m.set.length&&(v=0)},E=()=>{const t=m.set[v];if("task"===t){if(d.getState().context.currentTaskId){const{timer:t}=p.getState().context;if(t&&0!==t.time){let e;const a=p.getMarker("taskStart"),r=Date.now()-1e3*m.betweenTasksGracePeriod;a&&a.timestamp>r?e={timer:{time:a.timer.time,totalTime:t.totalTime,type:t.type},timestamp:a.timestamp}:p.setMarker("taskStart"),l("taskStart",g(e))}else p.createTimer({time:m.taskTime,type:i.task});return d.setAppState(a.task)}return d.setAppState(a.selectTask)}if("shortBreak"===t)return p.createTimer({time:m.shortBreakTime,type:i.shortBreak}),d.setAppState(a.shortBreak);if("longBreak"===t)return p.createTimer({time:m.longBreakTime,type:i.longBreak}),d.setAppState(a.longBreak);throw new Error(`Unknown set item: "${t}"`)},I=()=>{const t=d.getState(),e=p.getState(),a=S.getState(),i=e.context.timer?{isActive:e.value===r.active,isInjected:e.context.timer.isInjected,isPaused:e.value===r.paused,time:e.context.timer.time,totalTime:e.context.timer.totalTime,type:e.context.timer.type}:null;return{status:t.value,currentTaskId:t.context.currentTaskId,timer:i,overtime:a.context.overtime}},h=()=>{var t;S.getState().value===e.active&&l("overtimeEnd",g()),S.endOvertime();const a=p.getState(),s=a.value===r.paused,n=(null===(t=a.context.timer)||void 0===t?void 0:t.type)===i.task;s?l("timerResume",g()):(l("timerStart",g()),n&&l("taskStart",g())),p.startTimer(),p.setMarker("taskStart")},x=()=>{const t={};if(p.getState().value===r.idle){const e=p.getMarker("taskStart"),a=p.getMarker("taskEnd");e&&a&&(t.timer={time:e.timer.time,totalTime:e.timer.totalTime,type:e.timer.type},t.timestamp=a.timestamp)}l("taskVoid",g(t)),p.getState().value===r.active&&p.destroyTimer(),d.voidTask()};return{completeTask:()=>{l("taskEnd",g()),p.setMarker("taskStart"),d.completeTask()},getState:I,off:T,on:k,pauseTimer:()=>{p.pauseTimer(),l("timerPause",g())},selectTask:t=>{let e;d.selectTask(t);const a=p.getMarker("taskStart");a&&(e={timer:{time:a.timer.time,totalTime:a.timer.totalTime,type:a.timer.type},timestamp:a.timestamp}),l("taskSelect",g(e)),E()},setReady:()=>{E(),l("appInitialize",g())},skipTimer:()=>{l("timerSkip",g()),p.destroyTimer(),y(),E()},startTimer:h,switchTask:()=>{l("taskEnd",g()),p.setMarker("taskStart"),d.switchTask()},taskCompleteHandled:()=>{d.unsetCurrentTask(),E(),p.getState().value===r.ready&&h()},taskTimerEndPromptHandled:t=>{"voidTask"===t?(v-=1,v<0&&(v=m.set.length-1),x()):("switchTask"===t&&d.unsetCurrentTask(),E(),p.getState().value===r.ready&&h()),p.clearMarkers()},updateSettings:t=>{m=t},voidPromptHandled:()=>{d.setAppState(a.shortBreak),p.createTimer({isInjected:!0,time:m.shortBreakTime,type:i.shortBreak}),h()},voidTask:x}};export{n as default};
